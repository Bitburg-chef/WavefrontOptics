function wvfParams = wvfComputeConePSF(wvfParams)% wvfParams = wvfComputeConePSF(wvfParams)%% This routine finds PSFs seen by each cone class under passed spectrum weightingSpectrum.  It gets% these by taking a weighted sum of the monochromatic PSFs, where the weights are given by% the product of the passed LMS spectral sensitivities and the passed spectrum.  If SCE% is specified, the SCE at each wavelength is also incorporated when summing up the% monochromatic PSFs.%% The returned psfs are normalized so that they sum to unity.  If you want to figure% out the relative amount of light seen by each cone class, you need to take the% spectral sensitivities into account and also the SCE if you're using that.  The% routine does return the weighted average of the monochromatic sceFrac entries% for each cone type, to make this easier.%% Required input fields for wvfParams struct - see comment in wvfComputePupilFunction for more details.%   wls -               Column vector of wavelengths over which to cone sensitivity and spectrum are specified.%   T_cones -           Cone spectral sensitivities in Psychtoolbox data format.%   weightingSpectrum - Weighting spectrum as a column vector.%   zcoeffs -           Zernike coefficients.%   measpupilMM -       Size of pupil characterized by the coefficients, in MM.%   caclpupilsize -     Size over which returned pupil function is calculated, in MM.%   wls -               Column vector of wavelengths over which to compute, in NANOMETERS.%   nominalFocusWl -    Wavelength (in nm) of nominal focus.%   defocusDiopters -   Defocus to add in (signed), in diopters.%   sizeOfFieldPixels - Linear size of square image over which the pupil function is computed.%   sizeOfFieldMM -     Size of square image over which the pupile function is computed in MM.%% Optional input fields for wvfParams struct%   sceParams -         Parameter structure for Stiles-Crawford correction.  If missing or set to empty,%                       no correction and is set to empty on return.%% Output fields set in wvfParams struct%   conepsf -           Calcuated psf for each cone in T_cones, third dimension indexes cone type.%   coneSceFrac -       Vector with calculated SCE fraction for each cone type.%   psf -               Calcuated polychromatic psf. Third dimension of returned matrix indexes wavelength. %   pupilfunc -         Calculated pupil function.  Third dimension of returned matrix indexes wavelength%   arcminperpix -      Arc minutes per pixel for returned psfs.%   strehl -            Strehl ratio of psf at each wavelength.  If SCE correction is specified, the returned%                       strehl ratio is to the diffraction limited psf with the same SCE assumed.%   sceFrac -           Fraction of light actually absorbed when SCE is taken into account, at each wavelength.%   areapix -           Number of pixels within the computed pupil aperture at each wavelength%   areapixapod -       Number of pixels within the computed pupil aperture at each wavelength,%                       multiplied by the Stiles-Crawford aopdization.%   defocusMicrons -    Defocus added in to zcoeffs(4) at each wavelength, in microns.%% Note 1 on usage.  If you actually know the hyperspectral image input, you probably don't want to use this routine.% Rather, compute the monochromatic PSFs at each wavelength and do your optical blurring in the wavelength domain,% before computing cone absorbtions.  Doing so is a more accurate model of the physics.%% You would use this routine under two circumstances.  First, you might know that the image consists only of% intensity modulations of a single relative spectrum.  In this case, you could use that spectrum here and speed% things up, since you'd only have to convolve three times (one for each cone class rather than once for each% wavelength).  This case corresponds, for example, to psychophysics where achromatic contrast is manipulated.%% Second, you might only know the unblurred LMS images and not have spectral data.  Then, this routine is useful for% providing an approximation to the blurring that will occur for each cone class.  For example, your data might% originate with a high-resolution RGB camera image, which was then used to estimate LMS values at each location.% Keep in mind that what you get in that case is only an approximation, since the actual blur depends on the% full spectral image.%% Note 2 on usage.  If you want to compute a strehl ratio quantity for the LMS psfs, the most straightforward% way is to call this routine a second time using a zcoeffs vector of all zeros.  This leads to computation% of diffraction limited monochromatic psfs that are then summed just like the specified ones.  Taking the ratios% of the peaks then gives you a fairly meaningful figure of merit.%% See wvfComputePSF.%% 7/13/07   dhb    Made into a callable function, based on code provided by Heidi Hofer.%           dhb    Remove globals, fix case of fft, get rid of some vars we don't care about%           dhb    Don't write files here, optional plot supression.% 7/14/07   dhb    Change name a little.% 12/22/09  dhb    Return monochromatic PSFs as a cell array% 8/21/11   dhb    Update% 9/7/11    dhb    Rename.  Use wvfParams for i/o.% Handle default argsif (~isfield(wvfParams,'sceParams') || isempty(wvfParams.sceParams))    wvfParams.sceParams = [];end% Force wavelengths to column vector form, if PTB is on pathif (exist('MakeItWls','file'))    wvfParams.wls = MakeItWls(wvfParams.wls);endnWls = length(wvfParams.wls);% Get weighted cone fundamentals, and% normalize each so it sums to one.nCones = size(wvfParams.T_cones,1);coneWeight = zeros(nCones,nWls);for j = 1:nCones    coneWeight(j,:) = wvfParams.T_cones(j,:).*wvfParams.weightingSpectrum';endfor j = 1:nCones    coneWeight(j,:) = coneWeight(j,:)./sum(coneWeight(j,:));end% Get psfs for each cone typewvfParams = wvfComputePSF(wvfParams);[m,n] = size(wvfParams.psf(:,:,1));wvfParams.conepsf = zeros(m,n,nCones);for j = 1:nCones    for wl = 1:nWls        wvfParams.conepsf(:,:,j) = wvfParams.conepsf(:,:,j) + wvfParams.sceFrac(wl)*coneWeight(j,wl)*wvfParams.psf(:,:,wl);    endend% Normalize.  Because of the SCE, they might not be.for j = 1:nCones    wvfParams.conepsf(:,:,j) = wvfParams.conepsf(:,:,j)/sum(sum(wvfParams.conepsf(:,:,j)));end% Get sceFrac for each cone typefor j = 1:nCones    wvfParams.coneSceFrac(j,:) = coneWeight(j,:) .* wvfParams.sceFrac;end